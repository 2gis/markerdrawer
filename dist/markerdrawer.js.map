{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///markerdrawer.js","webpack:///webpack/bootstrap 2422e3a9a33c044f5a4f","webpack:///./src/Atlas.ts","webpack:///./src/MarkerDrawer.ts","webpack:///./~/bin-pack/index.js","webpack:///./~/bin-pack/packer.growing.js","webpack:///./~/quickselect/index.js","webpack:///./~/rbush/index.js","webpack:///./src/CanvasRenderer.ts","webpack:///./src/utils.ts"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","i","l","call","m","c","value","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","__webpack_exports__","Atlas","__WEBPACK_IMPORTED_MODULE_0_bin_pack__","icons","_this","sprites","_promise","Promise","all","map","icon","_imageLoad","image","then","_createSprite","whenReady","complete","resolve","addEventListener","arr","imageSize","width","height","size","margin","anchor","pixelDensity","packed","inPlace","position","x","y","canvas","document","createElement","ctx","getContext","shadowColor","shadowBlur","forEach","drawImage","MarkerDrawer","__WEBPACK_IMPORTED_MODULE_0__CanvasRenderer__","__extends","extendStatics","setPrototypeOf","__proto__","Array","b","__","constructor","create","_super","atlas","options","_onClick","ev","point","_getMousePosition","markers","_renderer","search","length","stopPropagation","event_1","originalEvent","fire","_atlas","_markers","debugDrawing","undefined","bufferFactor","zIndex","setMarkers","update","addTo","addLayer","onAdd","_map","_pane","getPane","onAddToMap","appendChild","container","remove","removeLayer","onRemove","removeChild","onRemoveFromMap","removeEventListener","setDebugDrawing","getContainer","rect","getBoundingClientRect","clientX","left","clientLeft","clientY","top","clientTop","L","Layer","GrowingPacker","items","packer","newItems","item","sort","a","fit","w","reduce","curr","Math","max","h","ret","blocks","node","block","len","findNode","splitNode","growNode","used","right","down","canGrowDown","canGrowRight","shouldGrowRight","shouldGrowDown","growRight","growDown","partialSort","k","compare","defaultCompare","z","log","exp","sd","sqrt","floor","min","t","j","swap","tmp","rbush","maxEntries","format","_maxEntries","_minEntries","ceil","_initFormat","clear","findItem","equalsFn","indexOf","calcBBox","toBBox","distBBox","children","destNode","createNode","minX","Infinity","minY","maxX","maxY","child","extend","leaf","compareNodeMinX","compareNodeMinY","bboxArea","bboxMargin","enlargedArea","intersectionArea","contains","intersects","multiSelect","mid","stack","pop","quickselect","push","_all","data","bbox","result","childBBox","nodesToSearch","collides","load","insert","_build","slice","_splitRoot","tmpNode","_insert","parent","index","goingUp","path","indexes","splice","_condense","compareMinX","compareMinY","toJSON","fromJSON","apply","N","M","pow","right2","right3","N2","N1","_chooseSubtree","level","targetNode","area","enlargement","minArea","minEnlargement","isNode","insertPath","_split","_adjustParentBBoxes","_chooseSplitAxis","splitIndex","_chooseSplitIndex","newNode","bbox1","bbox2","overlap","minOverlap","_allDistMargin","leftBBox","rightBBox","siblings","compareArr","Function","join","CanvasRenderer","__WEBPACK_IMPORTED_MODULE_0_rbush__","__WEBPACK_IMPORTED_MODULE_1__utils__","_isRendering","_isZooming","_needUpdate","_zoom","getZoom","center","getCenter","_origin","lng","lat","_mapSize","pixelOffset","containerPointToLayerPoint","_bufferOffset","round","DomUtil","setPosition","_hiddenFrame","_render","_onResize","mapSize","getSize","_pixelRatio","window","devicePixelRatio","_bufferFactor","_size","_currentFrame","style","_onZoomStart","_onMoveEnd","_renderLoop","from","_lastRenderedMarker","to","_markersPerFrame","_renderFinish","startTime","_renderPart","timeDelta","timePerMarker","_timePerFrame","_requestAnimationFrameId","requestAnimationFrame","_markersData","_debugDrawing","_vec","_createFrame","cancelAnimationFrame","markersData","on","viewreset","moveend","zoomstart","resize","off","clearRect","tree","_switchFrames","pixelRatio","offset","zoom","origin","bufferOffset","visibleMarkers","marker","sprite","iconIndex","spriteScale","_debugDraw","colors","drawingOffsets","drawingOffset","beginPath","strokeStyle","stroke","display","__WEBPACK_IMPORTED_MODULE_0__src_MarkerDrawer__","__WEBPACK_IMPORTED_MODULE_1__src_Atlas__","vec2create","Float64Array","lngLatToZoomPoint","out","lngLat","latLngToMapPoint","mapPointToScreenPoint","scale","PI","R","MAX_LATITUDE","sin","now","performance","bind","Date"],"mappings":"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","file":"markerdrawer.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MarkerDrawer\"] = factory();\n\telse\n\t\troot[\"MarkerDrawer\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MarkerDrawer\"] = factory();\n\telse\n\t\troot[\"MarkerDrawer\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// identity function for calling harmony imports with the correct context\n/******/ \t__webpack_require__.i = function(value) { return value; };\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, {\n/******/ \t\t\t\tconfigurable: false,\n/******/ \t\t\t\tenumerable: true,\n/******/ \t\t\t\tget: getter\n/******/ \t\t\t});\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 7);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return Atlas; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bin_pack__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_bin_pack___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_bin_pack__);\n\n/**\n * The Atlas creates one image from a set of icons.\n * After creating holds information about positions of each icon in the image.\n */\nvar Atlas = (function () {\n    function Atlas(icons) {\n        var _this = this;\n        this.sprites = [];\n        this._promise = Promise.all(icons.map(function (icon) { return _this._imageLoad(icon.image); }))\n            .then(function () { return _this._createSprite(icons); });\n    }\n    /**\n     * Returns a promise that will be resolve after all images loading done\n     */\n    Atlas.prototype.whenReady = function () {\n        return this._promise;\n    };\n    Atlas.prototype._imageLoad = function (image) {\n        if (image.complete) {\n            return Promise.resolve();\n        }\n        return new Promise(function (resolve) {\n            image.addEventListener('load', resolve);\n        });\n    };\n    Atlas.prototype._createSprite = function (icons) {\n        var margin = 2;\n        var arr = icons.map(function (icon) {\n            var imageSize = [icon.image.width, icon.image.height];\n            var size = icon.size || imageSize;\n            return {\n                // Data for bin-pack\n                width: size[0] + margin * 2,\n                height: size[1] + margin * 2,\n                // Data that we need after bin-pack\n                image: icon.image,\n                anchor: icon.anchor || [0.5, 0.5],\n                size: size,\n                imageSize: imageSize,\n                pixelDensity: icon.pixelDensity || 1,\n            };\n        });\n        var packed = __WEBPACK_IMPORTED_MODULE_0_bin_pack__(arr, { inPlace: true });\n        this.size = [packed.width, packed.height];\n        // Sum margins that get texture coordinates without margins\n        this.sprites = arr.map(function (icon) { return ({\n            position: [icon.x + margin, icon.y + margin],\n            size: icon.size,\n            anchor: icon.anchor,\n            pixelDensity: icon.pixelDensity,\n        }); });\n        var canvas = this.image = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        if (!ctx) {\n            return;\n        }\n        canvas.width = packed.width;\n        canvas.height = packed.height;\n        ctx.shadowColor = 'transparent';\n        ctx.shadowBlur = 0;\n        arr.forEach(function (icon) {\n            ctx.drawImage(icon.image, 0, 0, icon.imageSize[0], icon.imageSize[1], icon.x + margin, icon.y + margin, icon.size[0], icon.size[1]);\n        });\n    };\n    return Atlas;\n}());\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return MarkerDrawer; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__CanvasRenderer__ = __webpack_require__(6);\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\n\n/**\n * This class helps to draw fast a huge amount of markers\n */\nvar MarkerDrawer = (function (_super) {\n    __extends(MarkerDrawer, _super);\n    function MarkerDrawer(atlas, options) {\n        if (options === void 0) { options = {}; }\n        var _this = _super.call(this) || this;\n        _this._onClick = function (ev) {\n            var point = _this._getMousePosition(ev);\n            var markers = _this._renderer.search(point);\n            if (markers.length) {\n                ev.stopPropagation();\n                var event_1 = {\n                    originalEvent: ev,\n                    markers: markers,\n                };\n                _this.fire('click', event_1);\n            }\n        };\n        _this._atlas = atlas;\n        _this._markers = [];\n        _this._renderer = new __WEBPACK_IMPORTED_MODULE_0__CanvasRenderer__[\"a\" /* CanvasRenderer */](_this._atlas, options.debugDrawing || false, options.bufferFactor !== undefined ? options.bufferFactor : 0.5, options.zIndex);\n        return _this;\n    }\n    MarkerDrawer.prototype.setMarkers = function (markers) {\n        this._markers = markers;\n        this._renderer.setMarkers(markers);\n    };\n    MarkerDrawer.prototype.update = function () {\n        this._renderer.update();\n    };\n    MarkerDrawer.prototype.addTo = function (map) {\n        map.addLayer(this);\n        return this;\n    };\n    MarkerDrawer.prototype.onAdd = function () {\n        var _this = this;\n        if (!this._map) {\n            return this;\n        }\n        this._pane = this._map.getPane('overlayPane'); // overlayPane always exist\n        this._renderer.onAddToMap(this._map);\n        this._pane.addEventListener('click', this._onClick);\n        this._pane.appendChild(this._renderer.container);\n        this._atlas.whenReady()\n            .then(function () {\n            _this._renderer.update();\n        });\n        return this;\n    };\n    MarkerDrawer.prototype.remove = function () {\n        if (this._map) {\n            this._map.removeLayer(this);\n        }\n        return this;\n    };\n    MarkerDrawer.prototype.onRemove = function () {\n        this._pane.removeChild(this._renderer.container);\n        this._renderer.onRemoveFromMap();\n        this._renderer.container.removeEventListener('click', this._onClick);\n        return this;\n    };\n    MarkerDrawer.prototype.setDebugDrawing = function (value) {\n        this._renderer.setDebugDrawing(value);\n    };\n    MarkerDrawer.prototype._getMousePosition = function (ev) {\n        var map = this._map;\n        var container = map.getContainer();\n        var rect = container.getBoundingClientRect();\n        return [\n            ev.clientX - rect.left - container.clientLeft,\n            ev.clientY - rect.top - container.clientTop,\n        ];\n    };\n    return MarkerDrawer;\n}(L.Layer));\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nvar GrowingPacker = __webpack_require__(3);\n\nmodule.exports = function(items, options) {\n\toptions = options || {};\n\tvar packer = new GrowingPacker();\n\tvar inPlace = options.inPlace || false;\n\n\t// Clone the items.\n\tvar newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });\n\n\tnewItems = newItems.sort(function(a, b) {\n\t\t// TODO: check that each actually HAS a width and a height.\n\t\t// Sort based on the size (area) of each block.\n\t\treturn (b.width * b.height) - (a.width * a.height);\n\t});\n\n\tpacker.fit(newItems);\n\n\tvar w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);\n\tvar h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);\n\n\tvar ret = {\n\t\twidth: w,\n\t\theight: h\n\t};\n\n\tif (!inPlace) {\n\t\tret.items = newItems;\n\t}\n\n\treturn ret;\n};\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports) {\n\n/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/\n\nvar GrowingPacker = function() { };\n\nGrowingPacker.prototype = {\n\n\tfit: function(blocks) {\n\t\tvar n, node, block, len = blocks.length, fit;\n\t\tvar width  = len > 0 ? blocks[0].width : 0;\n\t\tvar height = len > 0 ? blocks[0].height : 0;\n\t\tthis.root = { x: 0, y: 0, width: width, height: height };\n\t\tfor (n = 0; n < len ; n++) {\n\t\t\tblock = blocks[n];\n\t\t\tif (node = this.findNode(this.root, block.width, block.height)) {\n\t\t\t\tfit = this.splitNode(node, block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfit = this.growNode(block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t}\n\t},\n\n\tfindNode: function(root, width, height) {\n\t\tif (root.used)\n\t\t\treturn this.findNode(root.right, width, height) || this.findNode(root.down, width, height);\n\t\telse if ((width <= root.width) && (height <= root.height))\n\t\t\treturn root;\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tsplitNode: function(node, width, height) {\n\t\tnode.used = true;\n\t\tnode.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };\n\t\tnode.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };\n\t\treturn node;\n\t},\n\n\tgrowNode: function(width, height) {\n\t\tvar canGrowDown  = (width  <= this.root.width);\n\t\tvar canGrowRight = (height <= this.root.height);\n\n\t\tvar shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width\n\t\tvar shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height\n\n\t\tif (shouldGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (shouldGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse if (canGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (canGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse\n\t\t\treturn null; // need to ensure sensible root starting size to avoid this happening\n\t},\n\n\tgrowRight: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width + width,\n\t\t\theight: this.root.height,\n\t\t\tdown: this.root,\n\t\t\tright: { x: this.root.width, y: 0, width: width, height: this.root.height }\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tgrowDown: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width,\n\t\t\theight: this.root.height + height,\n\t\t\tdown:  { x: 0, y: this.root.height, width: this.root.width, height: height },\n\t\t\tright: this.root\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t}\n\n};\n\nmodule.exports = GrowingPacker;\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = partialSort;\n\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n\nfunction partialSort(arr, k, left, right, compare) {\n    left = left || 0;\n    right = right || (arr.length - 1);\n    compare = compare || defaultCompare;\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            partialSort(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\nmodule.exports = rbush;\n\nvar quickselect = __webpack_require__(4);\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return CanvasRenderer; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rbush__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_rbush___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_rbush__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(8);\n\n\nvar CanvasRenderer = (function () {\n    function CanvasRenderer(atlas, debugDrawing, bufferFactor, zIndex) {\n        var _this = this;\n        this.update = function () {\n            if (!_this._map) {\n                return;\n            }\n            if (_this._isRendering || _this._isZooming) {\n                _this._needUpdate = true;\n                return;\n            }\n            _this._zoom = _this._map.getZoom();\n            var center = _this._map.getCenter();\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* lngLatToZoomPoint */])(_this._origin, [center.lng, center.lat], _this._zoom);\n            _this._origin[0] -= _this._mapSize[0] / 2;\n            _this._origin[1] -= _this._mapSize[1] / 2;\n            var pixelOffset = _this._map.containerPointToLayerPoint([\n                -_this._bufferOffset[0],\n                -_this._bufferOffset[1],\n            ]).round();\n            L.DomUtil.setPosition(_this._hiddenFrame.canvas, pixelOffset);\n            _this._render();\n        };\n        this._onResize = function () {\n            if (!_this._map) {\n                return;\n            }\n            var mapSize = _this._map.getSize();\n            _this._pixelRatio = window.devicePixelRatio;\n            _this._bufferOffset = [\n                Math.round(mapSize.x * _this._bufferFactor),\n                Math.round(mapSize.y * _this._bufferFactor),\n            ];\n            var size = _this._size = [\n                mapSize.x + _this._bufferOffset[0] * 2,\n                mapSize.y + _this._bufferOffset[1] * 2,\n            ];\n            _this._mapSize = [\n                mapSize.x,\n                mapSize.y,\n            ];\n            _this._currentFrame.canvas.width = size[0] * _this._pixelRatio;\n            _this._currentFrame.canvas.height = size[1] * _this._pixelRatio;\n            _this._currentFrame.canvas.style.width = size[0] + 'px';\n            _this._currentFrame.canvas.style.height = size[1] + 'px';\n            _this._hiddenFrame.canvas.width = size[0] * _this._pixelRatio;\n            _this._hiddenFrame.canvas.height = size[1] * _this._pixelRatio;\n            _this._hiddenFrame.canvas.style.width = size[0] + 'px';\n            _this._hiddenFrame.canvas.style.height = size[1] + 'px';\n        };\n        this._onZoomStart = function () {\n            _this.clear();\n            _this._isZooming = true;\n        };\n        this._onMoveEnd = function () {\n            _this._isZooming = false;\n            _this.update();\n        };\n        this._renderLoop = function () {\n            var from = _this._lastRenderedMarker;\n            var to = Math.min(from + _this._markersPerFrame, _this._markers.length);\n            if (from === to) {\n                _this._renderFinish();\n                return;\n            }\n            var startTime = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"b\" /* now */])();\n            _this._renderPart(from, to);\n            _this._lastRenderedMarker = to;\n            var timeDelta = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"b\" /* now */])() - startTime;\n            var timePerMarker = timeDelta / (to - from);\n            if (timePerMarker !== 0) {\n                _this._markersPerFrame = Math.max(Math.floor((_this._markersPerFrame + _this._timePerFrame / timePerMarker) / 2), 100);\n            }\n            if (to !== _this._markers.length) {\n                _this._requestAnimationFrameId = requestAnimationFrame(_this._renderLoop);\n            }\n            else {\n                _this._renderFinish();\n            }\n        };\n        this._atlas = atlas;\n        this._markers = [];\n        this._markersData = [];\n        this._isZooming = false;\n        this._debugDrawing = debugDrawing;\n        this._bufferFactor = bufferFactor;\n        this._markersPerFrame = 5000;\n        this._timePerFrame = 10;\n        this._origin = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"c\" /* vec2create */])();\n        this._vec = __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"c\" /* vec2create */])();\n        this._lastRenderedMarker = 0;\n        this._needUpdate = false;\n        this.container = document.createElement('div');\n        if (zIndex) {\n            this.container.style['z-index'] = zIndex;\n        }\n        this.container.style.position = 'absolute';\n        this._currentFrame = this._createFrame();\n        this._hiddenFrame = this._createFrame();\n    }\n    CanvasRenderer.prototype.setMarkers = function (markers) {\n        this._needUpdate = false;\n        if (this._isRendering) {\n            cancelAnimationFrame(this._requestAnimationFrameId);\n            this._isRendering = false;\n        }\n        // Set ordered indices\n        if (markers.length > this._markersData.length) {\n            var markersData = [];\n            for (var i = 0; i < markers.length; i++) {\n                markersData[i] = {\n                    index: i,\n                };\n            }\n            this._markersData = markersData;\n        }\n        this._markers = markers;\n        this.update();\n    };\n    CanvasRenderer.prototype.onAddToMap = function (map) {\n        this._map = map;\n        map.on({\n            viewreset: this.update,\n            moveend: this._onMoveEnd,\n            zoomstart: this._onZoomStart,\n            resize: this._onResize,\n        });\n        this._onResize();\n    };\n    CanvasRenderer.prototype.onRemoveFromMap = function () {\n        if (!this._map) {\n            return;\n        }\n        this._map.off({\n            viewreset: this.update,\n            moveend: this._onMoveEnd,\n            zoomstart: this._onZoomStart,\n            resize: this._onResize,\n        });\n        this._map = undefined;\n        this._markersData = [];\n        this._markers = [];\n    };\n    CanvasRenderer.prototype.clear = function () {\n        if (!this._map) {\n            return;\n        }\n        this._currentFrame.ctx.clearRect(0, 0, this._size[0] * this._pixelRatio, this._size[1] * this._pixelRatio);\n        this._currentFrame.tree.clear();\n        this._needUpdate = false;\n        if (this._isRendering) {\n            cancelAnimationFrame(this._requestAnimationFrameId);\n            this._isRendering = false;\n        }\n    };\n    CanvasRenderer.prototype.search = function (point) {\n        var x = (point[0] + this._bufferOffset[0]) * this._pixelRatio;\n        var y = (point[1] + this._bufferOffset[1]) * this._pixelRatio;\n        var res = this._currentFrame.tree.search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        });\n        return res.map(function (d) { return d.index; });\n    };\n    CanvasRenderer.prototype.setDebugDrawing = function (value) {\n        this._debugDrawing = value;\n    };\n    CanvasRenderer.prototype._render = function () {\n        if (!this._map) {\n            return;\n        }\n        this._hiddenFrame.tree.clear();\n        this._hiddenFrame.ctx.clearRect(0, 0, this._size[0] * this._pixelRatio, this._size[1] * this._pixelRatio);\n        this._isRendering = true;\n        this._lastRenderedMarker = 0;\n        this._renderLoop();\n    };\n    CanvasRenderer.prototype._renderFinish = function () {\n        this._isRendering = false;\n        this._switchFrames();\n        if (this._needUpdate) {\n            this._needUpdate = false;\n            this.update();\n        }\n    };\n    CanvasRenderer.prototype._renderPart = function (from, to) {\n        var markers = this._markers;\n        var markersData = this._markersData;\n        var atlas = this._atlas;\n        var debugDrawing = this._debugDrawing;\n        var pixelRatio = this._pixelRatio;\n        var size = this._size;\n        var ctx = this._hiddenFrame.ctx;\n        var offset = this._vec;\n        var zoom = this._zoom;\n        var origin = this._origin;\n        var bufferOffset = this._bufferOffset;\n        if (!atlas.image) {\n            return;\n        }\n        this._lastRenderedMarker = to;\n        var visibleMarkers = [];\n        for (var i = from; i < to; i++) {\n            var marker = markers[i];\n            var data = markersData[i];\n            var sprite = atlas.sprites[marker.iconIndex || 0];\n            if (!sprite) {\n                continue;\n            }\n            var spriteScale = pixelRatio / sprite.pixelDensity;\n            __webpack_require__.i(__WEBPACK_IMPORTED_MODULE_1__utils__[\"a\" /* lngLatToZoomPoint */])(offset, marker.position, zoom);\n            // Do not change the sequence of rounding, it corresponds to the rounding in Leaflet\n            offset[0] = Math.round(offset[0]);\n            offset[1] = Math.round(offset[1]);\n            offset[0] = Math.round(offset[0] - origin[0]) + bufferOffset[0];\n            offset[1] = Math.round(offset[1] - origin[1]) + bufferOffset[1];\n            offset[0] = Math.round(offset[0] * pixelRatio - sprite.size[0] * spriteScale * sprite.anchor[0]);\n            offset[1] = Math.round(offset[1] * pixelRatio - sprite.size[1] * spriteScale * sprite.anchor[1]);\n            if (offset[0] < 0 || offset[0] + sprite.size[0] * spriteScale > size[0] * pixelRatio ||\n                offset[1] < 0 || offset[1] + sprite.size[1] * spriteScale > size[1] * pixelRatio) {\n                continue;\n            }\n            // Prepare for rbush\n            data.minX = offset[0];\n            data.minY = offset[1];\n            data.maxX = offset[0] + sprite.size[0] * spriteScale;\n            data.maxY = offset[1] + sprite.size[1] * spriteScale;\n            visibleMarkers.push(data);\n            ctx.drawImage(atlas.image, sprite.position[0], sprite.position[1], sprite.size[0], sprite.size[1], offset[0], offset[1], sprite.size[0] * spriteScale, sprite.size[1] * spriteScale);\n            if (debugDrawing) {\n                this._debugDraw(marker, offset, sprite.size);\n            }\n        }\n        this._hiddenFrame.tree.load(visibleMarkers);\n    };\n    CanvasRenderer.prototype._debugDraw = function (marker, offset, size) {\n        var ctx = this._hiddenFrame.ctx;\n        var colors = [\n            '#000000',\n            '#ff0000',\n            '#00ff00',\n            '#0000ff',\n        ];\n        var drawingOffsets = marker.drawingOffsets;\n        if (!drawingOffsets) {\n            return;\n        }\n        for (var j = 0; j < drawingOffsets.length; j++) {\n            var drawingOffset = drawingOffsets[j];\n            ctx.beginPath();\n            ctx.strokeStyle = colors[j];\n            ctx.rect(offset[0] - drawingOffset, offset[1] - drawingOffset, size[0] + drawingOffset * 2, size[1] + drawingOffset * 2);\n            ctx.stroke();\n        }\n    };\n    CanvasRenderer.prototype._createFrame = function () {\n        var canvas = document.createElement('canvas');\n        canvas.style.display = 'none';\n        // In 2gis-maps a \"position: absolute\" style affects to the canvas\n        // Remove when 2gis-maps update leaflet to 1.0.3\n        canvas.style.position = 'initial';\n        // We do not consider the case when 2d context is not exist\n        var ctx = canvas.getContext('2d');\n        var tree = __WEBPACK_IMPORTED_MODULE_0_rbush__();\n        this.container.appendChild(canvas);\n        return {\n            canvas: canvas,\n            ctx: ctx,\n            tree: tree,\n        };\n    };\n    CanvasRenderer.prototype._switchFrames = function () {\n        if (!this._map) {\n            return;\n        }\n        this._currentFrame.canvas.style.display = 'none';\n        this._hiddenFrame.canvas.style.display = 'block';\n        var t = this._currentFrame;\n        this._currentFrame = this._hiddenFrame;\n        this._hiddenFrame = t;\n    };\n    return CanvasRenderer;\n}());\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\nObject.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_MarkerDrawer__ = __webpack_require__(1);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"MarkerDrawer\", function() { return __WEBPACK_IMPORTED_MODULE_0__src_MarkerDrawer__[\"a\"]; });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_Atlas__ = __webpack_require__(0);\n/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, \"Atlas\", function() { return __WEBPACK_IMPORTED_MODULE_1__src_Atlas__[\"a\"]; });\n\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (immutable) */ __webpack_exports__[\"c\"] = vec2create;\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = lngLatToZoomPoint;\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"b\", function() { return now; });\nvar R = 6378137;\nvar MAX_LATITUDE = 85.0511287798;\nfunction vec2create() {\n    return new Float64Array(2);\n}\nfunction lngLatToZoomPoint(out, lngLat, zoom) {\n    latLngToMapPoint(out, lngLat);\n    mapPointToScreenPoint(out, out, zoom);\n}\nfunction mapPointToScreenPoint(out, point, zoom) {\n    var scale = 256 * Math.pow(2, zoom);\n    var k = 0.5 / (Math.PI * R);\n    out[0] = scale * (k * point[0] + 0.5);\n    out[1] = scale * (-k * point[1] + 0.5);\n}\nfunction latLngToMapPoint(out, lngLat) {\n    var d = Math.PI / 180;\n    var lat = Math.max(Math.min(MAX_LATITUDE, lngLat[1]), -MAX_LATITUDE);\n    var sin = Math.sin(lat * d);\n    out[0] = R * lngLat[0] * d;\n    out[1] = R * Math.log((1 + sin) / (1 - sin)) / 2;\n}\nvar now = window.performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\n\n/***/ })\n/******/ ]);\n});\n\n\n// WEBPACK FOOTER //\n// markerdrawer.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// identity function for calling harmony imports with the correct context\n \t__webpack_require__.i = function(value) { return value; };\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2422e3a9a33c044f5a4f","import * as pack from 'bin-pack';\nimport { Vec2 } from './types';\n\n/**\n * Icon with options for atlas\n */\nexport interface Icon {\n    image: HTMLImageElement;\n    anchor?: Vec2; // [anchor=[0.5, 0.5]]\n    size?: Vec2; // [size=[image.width, image.height]] Size in a final atlas image\n    // Может отличаться от исходного размера изображения.\n    pixelDensity?: number; // Icon pixel density, 1 by default\n}\n\nexport interface Sprite {\n    position: Vec2; // Position of icon in the image of atlas\n    size: Vec2; // Size of icon in the atlas\n    anchor: Vec2;\n    pixelDensity: number; // Icon pixel density\n}\n\n/**\n * The Atlas creates one image from a set of icons.\n * After creating holds information about positions of each icon in the image.\n */\nexport class Atlas {\n    public image?: HTMLCanvasElement; // Image of icons\n    public size: Vec2; // Size of image\n    public sprites: Sprite[]; // Information about each icon\n\n    private _promise: Promise<any>;\n\n    constructor(icons: Icon[]) {\n        this.sprites = [];\n\n        this._promise = Promise.all<any>(icons.map((icon) => this._imageLoad(icon.image)))\n            .then(() => this._createSprite(icons));\n    }\n\n    /**\n     * Returns a promise that will be resolve after all images loading done\n     */\n    public whenReady() {\n        return this._promise;\n    }\n\n    private _imageLoad(image: HTMLImageElement) {\n        if (image.complete) {\n            return Promise.resolve();\n        }\n\n        return new Promise((resolve) => {\n            image.addEventListener('load', resolve);\n        });\n    }\n\n    private _createSprite(icons: Icon[]) {\n        const margin = 2;\n\n        const arr: any = icons.map((icon) => {\n            const imageSize = [icon.image.width, icon.image.height];\n            const size = icon.size || imageSize;\n\n            return {\n                // Data for bin-pack\n                width: size[0] + margin * 2,\n                height: size[1] + margin * 2,\n\n                // Data that we need after bin-pack\n                image: icon.image,\n                anchor: icon.anchor || [0.5, 0.5],\n                size,\n                imageSize,\n                pixelDensity: icon.pixelDensity || 1,\n            };\n        });\n\n        const packed = pack(arr, { inPlace: true });\n        this.size = [packed.width, packed.height];\n\n        // Sum margins that get texture coordinates without margins\n        this.sprites = arr.map((icon) => ({\n            position: [icon.x + margin, icon.y + margin],\n            size: icon.size,\n            anchor: icon.anchor,\n            pixelDensity: icon.pixelDensity,\n        }));\n\n        const canvas = this.image = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n\n        if (!ctx) {\n            return;\n        }\n\n        canvas.width = packed.width;\n        canvas.height = packed.height;\n\n        ctx.shadowColor = 'transparent';\n        ctx.shadowBlur = 0;\n\n        arr.forEach((icon) => {\n            ctx.drawImage(icon.image,\n                0, 0, icon.imageSize[0], icon.imageSize[1],\n                icon.x + margin, icon.y + margin, icon.size[0], icon.size[1],\n            );\n        });\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Atlas.ts","import { Atlas } from './Atlas';\nimport { CanvasRenderer } from './CanvasRenderer';\nimport { Marker, Vec2, MarkerDrawerMouseEvent } from './types';\n\nexport interface MarkerDrawerOptions {\n    debugDrawing?: boolean;\n    bufferFactor?: number;\n    zIndex?: number;\n}\n\n/**\n * This class helps to draw fast a huge amount of markers\n */\nexport class MarkerDrawer extends L.Layer {\n    private _markers: Marker[];\n    private _atlas: Atlas;\n    private _map?: L.Map;\n    private _renderer: CanvasRenderer;\n    private _pane: HTMLElement;\n\n    constructor(atlas: Atlas, options: MarkerDrawerOptions = {}) {\n        super();\n\n        this._atlas = atlas;\n        this._markers = [];\n        this._renderer = new CanvasRenderer(\n            this._atlas,\n            options.debugDrawing || false,\n            options.bufferFactor !== undefined ? options.bufferFactor : 0.5,\n            options.zIndex,\n        );\n    }\n\n    public setMarkers(markers: Marker[]) {\n        this._markers = markers;\n        this._renderer.setMarkers(markers);\n    }\n\n    public update() {\n        this._renderer.update();\n    }\n\n    public addTo(map: L.Map) {\n        map.addLayer(this);\n\n        return this;\n    }\n\n    public onAdd() {\n        if (!this._map) {\n            return this;\n        }\n\n        this._pane = this._map.getPane('overlayPane') as HTMLElement; // overlayPane always exist\n\n        this._renderer.onAddToMap(this._map);\n        this._pane.addEventListener('click', this._onClick);\n        this._pane.appendChild(this._renderer.container);\n        this._atlas.whenReady()\n            .then(() => {\n                this._renderer.update();\n            });\n\n        return this;\n    }\n\n    public remove() {\n        if (this._map) {\n            this._map.removeLayer(this);\n        }\n\n        return this;\n    }\n\n    public onRemove() {\n        this._pane.removeChild(this._renderer.container);\n        this._renderer.onRemoveFromMap();\n        this._renderer.container.removeEventListener('click', this._onClick);\n\n        return this;\n    }\n\n    public setDebugDrawing(value: boolean) {\n        this._renderer.setDebugDrawing(value);\n    }\n\n    private _onClick = (ev: MouseEvent) => {\n        const point = this._getMousePosition(ev);\n        const markers = this._renderer.search(point);\n\n        if (markers.length) {\n            ev.stopPropagation();\n            const event: MarkerDrawerMouseEvent = {\n                originalEvent: ev,\n                markers,\n            };\n            this.fire('click', event);\n        }\n    }\n\n    private _getMousePosition(ev: MouseEvent): Vec2 {\n        const map = this._map as L.Map;\n        const container = map.getContainer();\n        const rect = container.getBoundingClientRect();\n        return [\n            ev.clientX - rect.left - container.clientLeft,\n            ev.clientY - rect.top - container.clientTop,\n        ];\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/MarkerDrawer.ts","\"use strict\";\n\nvar GrowingPacker = require('./packer.growing.js');\n\nmodule.exports = function(items, options) {\n\toptions = options || {};\n\tvar packer = new GrowingPacker();\n\tvar inPlace = options.inPlace || false;\n\n\t// Clone the items.\n\tvar newItems = items.map(function(item) { return inPlace ? item : { width: item.width, height: item.height, item: item }; });\n\n\tnewItems = newItems.sort(function(a, b) {\n\t\t// TODO: check that each actually HAS a width and a height.\n\t\t// Sort based on the size (area) of each block.\n\t\treturn (b.width * b.height) - (a.width * a.height);\n\t});\n\n\tpacker.fit(newItems);\n\n\tvar w = newItems.reduce(function(curr, item) { return Math.max(curr, item.x + item.width); }, 0);\n\tvar h = newItems.reduce(function(curr, item) { return Math.max(curr, item.y + item.height); }, 0);\n\n\tvar ret = {\n\t\twidth: w,\n\t\theight: h\n\t};\n\n\tif (!inPlace) {\n\t\tret.items = newItems;\n\t}\n\n\treturn ret;\n};\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/bin-pack/index.js\n// module id = 2\n// module chunks = 0","/******************************************************************************\n\nThis is a binary tree based bin packing algorithm that is more complex than\nthe simple Packer (packer.js). Instead of starting off with a fixed width and\nheight, it starts with the width and height of the first block passed and then\ngrows as necessary to accomodate each subsequent block. As it grows it attempts\nto maintain a roughly square ratio by making 'smart' choices about whether to\ngrow right or down.\n\nWhen growing, the algorithm can only grow to the right OR down. Therefore, if\nthe new block is BOTH wider and taller than the current target then it will be\nrejected. This makes it very important to initialize with a sensible starting\nwidth and height. If you are providing sorted input (largest first) then this\nwill not be an issue.\n\nA potential way to solve this limitation would be to allow growth in BOTH\ndirections at once, but this requires maintaining a more complex tree\nwith 3 children (down, right and center) and that complexity can be avoided\nby simply chosing a sensible starting block.\n\nBest results occur when the input blocks are sorted by height, or even better\nwhen sorted by max(width,height).\n\nInputs:\n------\n\n\tblocks: array of any objects that have .w and .h attributes\n\nOutputs:\n-------\n\n\tmarks each block that fits with a .fit attribute pointing to a\n\tnode with .x and .y coordinates\n\nExample:\n-------\n\n\tvar blocks = [\n\t\t{ w: 100, h: 100 },\n\t\t{ w: 100, h: 100 },\n\t\t{ w:  80, h:  80 },\n\t\t{ w:  80, h:  80 },\n\t\tetc\n\t\tetc\n\t];\n\n\tvar packer = new GrowingPacker();\n\tpacker.fit(blocks);\n\n\tfor(var n = 0 ; n < blocks.length ; n++) {\n\t\tvar block = blocks[n];\n\t\tif (block.fit) {\n\t\t\tDraw(block.fit.x, block.fit.y, block.w, block.h);\n\t\t}\n\t}\n\n\n******************************************************************************/\n\nvar GrowingPacker = function() { };\n\nGrowingPacker.prototype = {\n\n\tfit: function(blocks) {\n\t\tvar n, node, block, len = blocks.length, fit;\n\t\tvar width  = len > 0 ? blocks[0].width : 0;\n\t\tvar height = len > 0 ? blocks[0].height : 0;\n\t\tthis.root = { x: 0, y: 0, width: width, height: height };\n\t\tfor (n = 0; n < len ; n++) {\n\t\t\tblock = blocks[n];\n\t\t\tif (node = this.findNode(this.root, block.width, block.height)) {\n\t\t\t\tfit = this.splitNode(node, block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfit = this.growNode(block.width, block.height);\n\t\t\t\tblock.x = fit.x;\n\t\t\t\tblock.y = fit.y;\n\t\t\t}\n\t\t}\n\t},\n\n\tfindNode: function(root, width, height) {\n\t\tif (root.used)\n\t\t\treturn this.findNode(root.right, width, height) || this.findNode(root.down, width, height);\n\t\telse if ((width <= root.width) && (height <= root.height))\n\t\t\treturn root;\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tsplitNode: function(node, width, height) {\n\t\tnode.used = true;\n\t\tnode.down  = { x: node.x,         y: node.y + height, width: node.width,         height: node.height - height };\n\t\tnode.right = { x: node.x + width, y: node.y,          width: node.width - width, height: height               };\n\t\treturn node;\n\t},\n\n\tgrowNode: function(width, height) {\n\t\tvar canGrowDown  = (width  <= this.root.width);\n\t\tvar canGrowRight = (height <= this.root.height);\n\n\t\tvar shouldGrowRight = canGrowRight && (this.root.height >= (this.root.width  + width )); // attempt to keep square-ish by growing right when height is much greater than width\n\t\tvar shouldGrowDown  = canGrowDown  && (this.root.width  >= (this.root.height + height)); // attempt to keep square-ish by growing down  when width  is much greater than height\n\n\t\tif (shouldGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (shouldGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse if (canGrowRight)\n\t\t\treturn this.growRight(width, height);\n\t\telse if (canGrowDown)\n\t\t\treturn this.growDown(width, height);\n\t\telse\n\t\t\treturn null; // need to ensure sensible root starting size to avoid this happening\n\t},\n\n\tgrowRight: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width + width,\n\t\t\theight: this.root.height,\n\t\t\tdown: this.root,\n\t\t\tright: { x: this.root.width, y: 0, width: width, height: this.root.height }\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t},\n\n\tgrowDown: function(width, height) {\n\t\tthis.root = {\n\t\t\tused: true,\n\t\t\tx: 0,\n\t\t\ty: 0,\n\t\t\twidth: this.root.width,\n\t\t\theight: this.root.height + height,\n\t\t\tdown:  { x: 0, y: this.root.height, width: this.root.width, height: height },\n\t\t\tright: this.root\n\t\t};\n\t\tvar node;\n\t\tif (node = this.findNode(this.root, width, height))\n\t\t\treturn this.splitNode(node, width, height);\n\t\telse\n\t\t\treturn null;\n\t}\n\n};\n\nmodule.exports = GrowingPacker;\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/bin-pack/packer.growing.js\n// module id = 3\n// module chunks = 0","'use strict';\n\nmodule.exports = partialSort;\n\n// Floyd-Rivest selection algorithm:\n// Rearrange items so that all items in the [left, k] range are smaller than all items in (k, right];\n// The k-th element will have the (k - left + 1)th smallest value in [left, right]\n\nfunction partialSort(arr, k, left, right, compare) {\n    left = left || 0;\n    right = right || (arr.length - 1);\n    compare = compare || defaultCompare;\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            partialSort(arr, k, newLeft, newRight, compare);\n        }\n\n        var t = arr[k];\n        var i = left;\n        var j = right;\n\n        swap(arr, left, k);\n        if (compare(arr[right], t) > 0) swap(arr, left, right);\n\n        while (i < j) {\n            swap(arr, i, j);\n            i++;\n            j--;\n            while (compare(arr[i], t) < 0) i++;\n            while (compare(arr[j], t) > 0) j--;\n        }\n\n        if (compare(arr[left], t) === 0) swap(arr, left, j);\n        else {\n            j++;\n            swap(arr, j, right);\n        }\n\n        if (j <= k) left = j + 1;\n        if (k <= j) right = j - 1;\n    }\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction defaultCompare(a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/quickselect/index.js\n// module id = 4\n// module chunks = 0","'use strict';\n\nmodule.exports = rbush;\n\nvar quickselect = require('quickselect');\n\nfunction rbush(maxEntries, format) {\n    if (!(this instanceof rbush)) return new rbush(maxEntries, format);\n\n    // max entries in a node is 9 by default; min node fill is 40% for best performance\n    this._maxEntries = Math.max(4, maxEntries || 9);\n    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));\n\n    if (format) {\n        this._initFormat(format);\n    }\n\n    this.clear();\n}\n\nrbush.prototype = {\n\n    all: function () {\n        return this._all(this.data, []);\n    },\n\n    search: function (bbox) {\n\n        var node = this.data,\n            result = [],\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return result;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf) result.push(child);\n                    else if (contains(bbox, childBBox)) this._all(child, result);\n                    else nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return result;\n    },\n\n    collides: function (bbox) {\n\n        var node = this.data,\n            toBBox = this.toBBox;\n\n        if (!intersects(bbox, node)) return false;\n\n        var nodesToSearch = [],\n            i, len, child, childBBox;\n\n        while (node) {\n            for (i = 0, len = node.children.length; i < len; i++) {\n\n                child = node.children[i];\n                childBBox = node.leaf ? toBBox(child) : child;\n\n                if (intersects(bbox, childBBox)) {\n                    if (node.leaf || contains(bbox, childBBox)) return true;\n                    nodesToSearch.push(child);\n                }\n            }\n            node = nodesToSearch.pop();\n        }\n\n        return false;\n    },\n\n    load: function (data) {\n        if (!(data && data.length)) return this;\n\n        if (data.length < this._minEntries) {\n            for (var i = 0, len = data.length; i < len; i++) {\n                this.insert(data[i]);\n            }\n            return this;\n        }\n\n        // recursively build the tree with the given data from stratch using OMT algorithm\n        var node = this._build(data.slice(), 0, data.length - 1, 0);\n\n        if (!this.data.children.length) {\n            // save as is if tree is empty\n            this.data = node;\n\n        } else if (this.data.height === node.height) {\n            // split root if trees have the same height\n            this._splitRoot(this.data, node);\n\n        } else {\n            if (this.data.height < node.height) {\n                // swap trees if inserted one is bigger\n                var tmpNode = this.data;\n                this.data = node;\n                node = tmpNode;\n            }\n\n            // insert the small tree into the large tree at appropriate level\n            this._insert(node, this.data.height - node.height - 1, true);\n        }\n\n        return this;\n    },\n\n    insert: function (item) {\n        if (item) this._insert(item, this.data.height - 1);\n        return this;\n    },\n\n    clear: function () {\n        this.data = createNode([]);\n        return this;\n    },\n\n    remove: function (item, equalsFn) {\n        if (!item) return this;\n\n        var node = this.data,\n            bbox = this.toBBox(item),\n            path = [],\n            indexes = [],\n            i, parent, index, goingUp;\n\n        // depth-first iterative tree traversal\n        while (node || path.length) {\n\n            if (!node) { // go up\n                node = path.pop();\n                parent = path[path.length - 1];\n                i = indexes.pop();\n                goingUp = true;\n            }\n\n            if (node.leaf) { // check current node\n                index = findItem(item, node.children, equalsFn);\n\n                if (index !== -1) {\n                    // item found, remove the item and condense tree upwards\n                    node.children.splice(index, 1);\n                    path.push(node);\n                    this._condense(path);\n                    return this;\n                }\n            }\n\n            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down\n                path.push(node);\n                indexes.push(i);\n                i = 0;\n                parent = node;\n                node = node.children[0];\n\n            } else if (parent) { // go right\n                i++;\n                node = parent.children[i];\n                goingUp = false;\n\n            } else node = null; // nothing found\n        }\n\n        return this;\n    },\n\n    toBBox: function (item) { return item; },\n\n    compareMinX: compareNodeMinX,\n    compareMinY: compareNodeMinY,\n\n    toJSON: function () { return this.data; },\n\n    fromJSON: function (data) {\n        this.data = data;\n        return this;\n    },\n\n    _all: function (node, result) {\n        var nodesToSearch = [];\n        while (node) {\n            if (node.leaf) result.push.apply(result, node.children);\n            else nodesToSearch.push.apply(nodesToSearch, node.children);\n\n            node = nodesToSearch.pop();\n        }\n        return result;\n    },\n\n    _build: function (items, left, right, height) {\n\n        var N = right - left + 1,\n            M = this._maxEntries,\n            node;\n\n        if (N <= M) {\n            // reached leaf level; return leaf\n            node = createNode(items.slice(left, right + 1));\n            calcBBox(node, this.toBBox);\n            return node;\n        }\n\n        if (!height) {\n            // target height of the bulk-loaded tree\n            height = Math.ceil(Math.log(N) / Math.log(M));\n\n            // target number of root entries to maximize storage utilization\n            M = Math.ceil(N / Math.pow(M, height - 1));\n        }\n\n        node = createNode([]);\n        node.leaf = false;\n        node.height = height;\n\n        // split the items into M mostly square tiles\n\n        var N2 = Math.ceil(N / M),\n            N1 = N2 * Math.ceil(Math.sqrt(M)),\n            i, j, right2, right3;\n\n        multiSelect(items, left, right, N1, this.compareMinX);\n\n        for (i = left; i <= right; i += N1) {\n\n            right2 = Math.min(i + N1 - 1, right);\n\n            multiSelect(items, i, right2, N2, this.compareMinY);\n\n            for (j = i; j <= right2; j += N2) {\n\n                right3 = Math.min(j + N2 - 1, right2);\n\n                // pack each entry recursively\n                node.children.push(this._build(items, j, right3, height - 1));\n            }\n        }\n\n        calcBBox(node, this.toBBox);\n\n        return node;\n    },\n\n    _chooseSubtree: function (bbox, node, level, path) {\n\n        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;\n\n        while (true) {\n            path.push(node);\n\n            if (node.leaf || path.length - 1 === level) break;\n\n            minArea = minEnlargement = Infinity;\n\n            for (i = 0, len = node.children.length; i < len; i++) {\n                child = node.children[i];\n                area = bboxArea(child);\n                enlargement = enlargedArea(bbox, child) - area;\n\n                // choose entry with the least area enlargement\n                if (enlargement < minEnlargement) {\n                    minEnlargement = enlargement;\n                    minArea = area < minArea ? area : minArea;\n                    targetNode = child;\n\n                } else if (enlargement === minEnlargement) {\n                    // otherwise choose one with the smallest area\n                    if (area < minArea) {\n                        minArea = area;\n                        targetNode = child;\n                    }\n                }\n            }\n\n            node = targetNode || node.children[0];\n        }\n\n        return node;\n    },\n\n    _insert: function (item, level, isNode) {\n\n        var toBBox = this.toBBox,\n            bbox = isNode ? item : toBBox(item),\n            insertPath = [];\n\n        // find the best node for accommodating the item, saving all nodes along the path too\n        var node = this._chooseSubtree(bbox, this.data, level, insertPath);\n\n        // put the item into the node\n        node.children.push(item);\n        extend(node, bbox);\n\n        // split on node overflow; propagate upwards if necessary\n        while (level >= 0) {\n            if (insertPath[level].children.length > this._maxEntries) {\n                this._split(insertPath, level);\n                level--;\n            } else break;\n        }\n\n        // adjust bboxes along the insertion path\n        this._adjustParentBBoxes(bbox, insertPath, level);\n    },\n\n    // split overflowed node into two\n    _split: function (insertPath, level) {\n\n        var node = insertPath[level],\n            M = node.children.length,\n            m = this._minEntries;\n\n        this._chooseSplitAxis(node, m, M);\n\n        var splitIndex = this._chooseSplitIndex(node, m, M);\n\n        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));\n        newNode.height = node.height;\n        newNode.leaf = node.leaf;\n\n        calcBBox(node, this.toBBox);\n        calcBBox(newNode, this.toBBox);\n\n        if (level) insertPath[level - 1].children.push(newNode);\n        else this._splitRoot(node, newNode);\n    },\n\n    _splitRoot: function (node, newNode) {\n        // split root node\n        this.data = createNode([node, newNode]);\n        this.data.height = node.height + 1;\n        this.data.leaf = false;\n        calcBBox(this.data, this.toBBox);\n    },\n\n    _chooseSplitIndex: function (node, m, M) {\n\n        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;\n\n        minOverlap = minArea = Infinity;\n\n        for (i = m; i <= M - m; i++) {\n            bbox1 = distBBox(node, 0, i, this.toBBox);\n            bbox2 = distBBox(node, i, M, this.toBBox);\n\n            overlap = intersectionArea(bbox1, bbox2);\n            area = bboxArea(bbox1) + bboxArea(bbox2);\n\n            // choose distribution with minimum overlap\n            if (overlap < minOverlap) {\n                minOverlap = overlap;\n                index = i;\n\n                minArea = area < minArea ? area : minArea;\n\n            } else if (overlap === minOverlap) {\n                // otherwise choose distribution with minimum area\n                if (area < minArea) {\n                    minArea = area;\n                    index = i;\n                }\n            }\n        }\n\n        return index;\n    },\n\n    // sorts node children by the best axis for split\n    _chooseSplitAxis: function (node, m, M) {\n\n        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,\n            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,\n            xMargin = this._allDistMargin(node, m, M, compareMinX),\n            yMargin = this._allDistMargin(node, m, M, compareMinY);\n\n        // if total distributions margin value is minimal for x, sort by minX,\n        // otherwise it's already sorted by minY\n        if (xMargin < yMargin) node.children.sort(compareMinX);\n    },\n\n    // total margin of all possible split distributions where each node is at least m full\n    _allDistMargin: function (node, m, M, compare) {\n\n        node.children.sort(compare);\n\n        var toBBox = this.toBBox,\n            leftBBox = distBBox(node, 0, m, toBBox),\n            rightBBox = distBBox(node, M - m, M, toBBox),\n            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),\n            i, child;\n\n        for (i = m; i < M - m; i++) {\n            child = node.children[i];\n            extend(leftBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(leftBBox);\n        }\n\n        for (i = M - m - 1; i >= m; i--) {\n            child = node.children[i];\n            extend(rightBBox, node.leaf ? toBBox(child) : child);\n            margin += bboxMargin(rightBBox);\n        }\n\n        return margin;\n    },\n\n    _adjustParentBBoxes: function (bbox, path, level) {\n        // adjust bboxes along the given tree path\n        for (var i = level; i >= 0; i--) {\n            extend(path[i], bbox);\n        }\n    },\n\n    _condense: function (path) {\n        // go through the path, removing empty nodes and updating bboxes\n        for (var i = path.length - 1, siblings; i >= 0; i--) {\n            if (path[i].children.length === 0) {\n                if (i > 0) {\n                    siblings = path[i - 1].children;\n                    siblings.splice(siblings.indexOf(path[i]), 1);\n\n                } else this.clear();\n\n            } else calcBBox(path[i], this.toBBox);\n        }\n    },\n\n    _initFormat: function (format) {\n        // data format (minX, minY, maxX, maxY accessors)\n\n        // uses eval-type function compilation instead of just accepting a toBBox function\n        // because the algorithms are very sensitive to sorting functions performance,\n        // so they should be dead simple and without inner calls\n\n        var compareArr = ['return a', ' - b', ';'];\n\n        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));\n        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));\n\n        this.toBBox = new Function('a',\n            'return {minX: a' + format[0] +\n            ', minY: a' + format[1] +\n            ', maxX: a' + format[2] +\n            ', maxY: a' + format[3] + '};');\n    }\n};\n\nfunction findItem(item, items, equalsFn) {\n    if (!equalsFn) return items.indexOf(item);\n\n    for (var i = 0; i < items.length; i++) {\n        if (equalsFn(item, items[i])) return i;\n    }\n    return -1;\n}\n\n// calculate node's bbox from bboxes of its children\nfunction calcBBox(node, toBBox) {\n    distBBox(node, 0, node.children.length, toBBox, node);\n}\n\n// min bounding rectangle of node children from k to p-1\nfunction distBBox(node, k, p, toBBox, destNode) {\n    if (!destNode) destNode = createNode(null);\n    destNode.minX = Infinity;\n    destNode.minY = Infinity;\n    destNode.maxX = -Infinity;\n    destNode.maxY = -Infinity;\n\n    for (var i = k, child; i < p; i++) {\n        child = node.children[i];\n        extend(destNode, node.leaf ? toBBox(child) : child);\n    }\n\n    return destNode;\n}\n\nfunction extend(a, b) {\n    a.minX = Math.min(a.minX, b.minX);\n    a.minY = Math.min(a.minY, b.minY);\n    a.maxX = Math.max(a.maxX, b.maxX);\n    a.maxY = Math.max(a.maxY, b.maxY);\n    return a;\n}\n\nfunction compareNodeMinX(a, b) { return a.minX - b.minX; }\nfunction compareNodeMinY(a, b) { return a.minY - b.minY; }\n\nfunction bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }\nfunction bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }\n\nfunction enlargedArea(a, b) {\n    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *\n           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));\n}\n\nfunction intersectionArea(a, b) {\n    var minX = Math.max(a.minX, b.minX),\n        minY = Math.max(a.minY, b.minY),\n        maxX = Math.min(a.maxX, b.maxX),\n        maxY = Math.min(a.maxY, b.maxY);\n\n    return Math.max(0, maxX - minX) *\n           Math.max(0, maxY - minY);\n}\n\nfunction contains(a, b) {\n    return a.minX <= b.minX &&\n           a.minY <= b.minY &&\n           b.maxX <= a.maxX &&\n           b.maxY <= a.maxY;\n}\n\nfunction intersects(a, b) {\n    return b.minX <= a.maxX &&\n           b.minY <= a.maxY &&\n           b.maxX >= a.minX &&\n           b.maxY >= a.minY;\n}\n\nfunction createNode(children) {\n    return {\n        children: children,\n        height: 1,\n        leaf: true,\n        minX: Infinity,\n        minY: Infinity,\n        maxX: -Infinity,\n        maxY: -Infinity\n    };\n}\n\n// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;\n// combines selection algorithm with binary divide & conquer approach\n\nfunction multiSelect(arr, left, right, n, compare) {\n    var stack = [left, right],\n        mid;\n\n    while (stack.length) {\n        right = stack.pop();\n        left = stack.pop();\n\n        if (right - left <= n) continue;\n\n        mid = left + Math.ceil((right - left) / n / 2) * n;\n        quickselect(arr, mid, left, right, compare);\n\n        stack.push(left, mid, mid, right);\n    }\n}\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/rbush/index.js\n// module id = 5\n// module chunks = 0","import { Atlas } from './Atlas';\nimport * as rbush from 'rbush';\nimport {\n    Marker,\n    IRenderer,\n    Vec2,\n} from './types';\n\nimport {\n    lngLatToZoomPoint,\n    vec2create,\n    now,\n} from './utils';\n\ninterface MarkerData {\n    index: number;\n    minX?: number;\n    maxX?: number;\n    minY?: number;\n    maxY?: number;\n}\n\ninterface Frame {\n    canvas: HTMLCanvasElement;\n    ctx: CanvasRenderingContext2D;\n    tree: any;\n}\n\nexport class CanvasRenderer implements IRenderer {\n    public container: HTMLDivElement;\n\n    private _atlas: Atlas;\n\n    private _markers: Marker[];\n    private _markersData: MarkerData[];\n    private _isZooming: boolean;\n\n    private _debugDrawing: boolean;\n\n    private _map: L.Map | undefined;\n    private _size: Vec2;\n    private _mapSize: Vec2;\n    private _zoom: number;\n    private _bufferFactor: number;\n    private _bufferOffset: Vec2;\n\n    private _origin: Vec2;\n    private _pixelRatio: number;\n\n    private _currentFrame: Frame;\n    private _hiddenFrame: Frame;\n    private _isRendering: boolean;\n    private _timePerFrame: number;\n    private _markersPerFrame: number;\n    private _lastRenderedMarker: number;\n    private _needUpdate: boolean;\n    private _requestAnimationFrameId: number;\n\n    private _vec: Vec2;\n\n    constructor(atlas: Atlas, debugDrawing: boolean, bufferFactor: number, zIndex?: number) {\n        this._atlas = atlas;\n        this._markers = [];\n        this._markersData = [];\n        this._isZooming = false;\n        this._debugDrawing = debugDrawing;\n        this._bufferFactor = bufferFactor;\n        this._markersPerFrame = 5000;\n        this._timePerFrame = 10;\n        this._origin = vec2create();\n        this._vec = vec2create();\n        this._lastRenderedMarker = 0;\n        this._needUpdate = false;\n\n        this.container = document.createElement('div');\n        if (zIndex) {\n            this.container.style['z-index'] = zIndex;\n        }\n        this.container.style.position = 'absolute';\n        this._currentFrame = this._createFrame();\n        this._hiddenFrame = this._createFrame();\n    }\n\n    public setMarkers(markers: Marker[]) {\n        this._needUpdate = false;\n\n        if (this._isRendering) {\n            cancelAnimationFrame(this._requestAnimationFrameId);\n            this._isRendering = false;\n        }\n\n        // Set ordered indices\n        if (markers.length > this._markersData.length) {\n            const markersData: MarkerData[] = [];\n            for (let i = 0; i < markers.length; i++) {\n                markersData[i] = {\n                    index: i,\n                };\n            }\n            this._markersData = markersData;\n        }\n\n        this._markers = markers;\n\n        this.update();\n    }\n\n    public onAddToMap(map: L.Map) {\n        this._map = map;\n        map.on({\n            viewreset: this.update,\n            moveend: this._onMoveEnd,\n            zoomstart: this._onZoomStart,\n            resize: this._onResize,\n        });\n        this._onResize();\n    }\n\n    public onRemoveFromMap() {\n        if (!this._map) {\n            return;\n        }\n\n        this._map.off({\n            viewreset: this.update,\n            moveend: this._onMoveEnd,\n            zoomstart: this._onZoomStart,\n            resize: this._onResize,\n        });\n\n        this._map = undefined;\n        this._markersData = [];\n        this._markers = [];\n    }\n\n    public clear() {\n        if (!this._map) {\n            return;\n        }\n        this._currentFrame.ctx.clearRect(0, 0, this._size[0] * this._pixelRatio, this._size[1] * this._pixelRatio);\n        this._currentFrame.tree.clear();\n        this._needUpdate = false;\n\n        if (this._isRendering) {\n            cancelAnimationFrame(this._requestAnimationFrameId);\n            this._isRendering = false;\n        }\n    }\n\n    public update = () => {\n        if (!this._map) {\n            return;\n        }\n\n        if (this._isRendering || this._isZooming) {\n            this._needUpdate = true;\n            return;\n        }\n\n        this._zoom = this._map.getZoom();\n        const center = this._map.getCenter();\n\n        lngLatToZoomPoint(this._origin, [center.lng, center.lat], this._zoom);\n        this._origin[0] -= this._mapSize[0] / 2;\n        this._origin[1] -= this._mapSize[1] / 2;\n\n        const pixelOffset = this._map.containerPointToLayerPoint([\n            -this._bufferOffset[0],\n            -this._bufferOffset[1],\n        ]).round();\n\n        L.DomUtil.setPosition(this._hiddenFrame.canvas, pixelOffset);\n\n        this._render();\n    }\n\n    public search(point: Vec2) {\n        const x = (point[0] + this._bufferOffset[0]) * this._pixelRatio;\n        const y = (point[1] + this._bufferOffset[1]) * this._pixelRatio;\n        const res: MarkerData[] = this._currentFrame.tree.search({\n            minX: x,\n            minY: y,\n            maxX: x,\n            maxY: y,\n        });\n\n        return res.map((d) => d.index);\n    }\n\n    public setDebugDrawing(value: boolean) {\n        this._debugDrawing = value;\n    }\n\n    private _onResize = () => {\n        if (!this._map) {\n            return;\n        }\n\n        const mapSize = this._map.getSize();\n        this._pixelRatio = window.devicePixelRatio;\n\n        this._bufferOffset = [\n            Math.round(mapSize.x * this._bufferFactor),\n            Math.round(mapSize.y * this._bufferFactor),\n        ];\n\n        const size = this._size = [\n            mapSize.x + this._bufferOffset[0] * 2,\n            mapSize.y + this._bufferOffset[1] * 2,\n        ];\n\n        this._mapSize = [\n            mapSize.x,\n            mapSize.y,\n        ];\n\n        this._currentFrame.canvas.width = size[0] * this._pixelRatio;\n        this._currentFrame.canvas.height = size[1] * this._pixelRatio;\n        this._currentFrame.canvas.style.width = size[0] + 'px';\n        this._currentFrame.canvas.style.height = size[1] + 'px';\n\n        this._hiddenFrame.canvas.width = size[0] * this._pixelRatio;\n        this._hiddenFrame.canvas.height = size[1] * this._pixelRatio;\n        this._hiddenFrame.canvas.style.width = size[0] + 'px';\n        this._hiddenFrame.canvas.style.height = size[1] + 'px';\n    }\n\n    private _onZoomStart = () => {\n        this.clear();\n        this._isZooming = true;\n    }\n\n    private _onMoveEnd = () => {\n        this._isZooming = false;\n        this.update();\n    }\n\n    private _render() {\n        if (!this._map) {\n            return;\n        }\n\n        this._hiddenFrame.tree.clear();\n        this._hiddenFrame.ctx.clearRect(0, 0, this._size[0] * this._pixelRatio, this._size[1] * this._pixelRatio);\n\n        this._isRendering = true;\n        this._lastRenderedMarker = 0;\n\n        this._renderLoop();\n    }\n\n    private _renderLoop = () => {\n        const from = this._lastRenderedMarker;\n        const to = Math.min(from + this._markersPerFrame, this._markers.length);\n\n        if (from === to) {\n            this._renderFinish();\n            return;\n        }\n\n        const startTime = now();\n\n        this._renderPart(\n            from,\n            to,\n        );\n\n        this._lastRenderedMarker = to;\n\n        const timeDelta = now() - startTime;\n        const timePerMarker = timeDelta / (to - from);\n        if (timePerMarker !== 0) {\n            this._markersPerFrame = Math.max(\n                Math.floor((this._markersPerFrame + this._timePerFrame / timePerMarker) / 2),\n                100,\n            );\n        }\n\n        if (to !== this._markers.length) {\n            this._requestAnimationFrameId = requestAnimationFrame(this._renderLoop);\n        } else {\n            this._renderFinish();\n        }\n    }\n\n    private _renderFinish() {\n        this._isRendering = false;\n        this._switchFrames();\n\n        if (this._needUpdate) {\n            this._needUpdate = false;\n            this.update();\n        }\n    }\n\n    private _renderPart(\n        from: number,\n        to: number,\n    ) {\n        const markers = this._markers;\n        const markersData = this._markersData;\n        const atlas = this._atlas;\n        const debugDrawing = this._debugDrawing;\n        const pixelRatio = this._pixelRatio;\n        const size = this._size;\n        const ctx = this._hiddenFrame.ctx;\n        const offset = this._vec;\n        const zoom = this._zoom;\n        const origin = this._origin;\n        const bufferOffset = this._bufferOffset;\n\n        if (!atlas.image) {\n            return;\n        }\n\n        this._lastRenderedMarker = to;\n\n        const visibleMarkers: MarkerData[] = [];\n\n        for (let i = from; i < to; i++) {\n            const marker = markers[i];\n            const data = markersData[i];\n\n            const sprite = atlas.sprites[marker.iconIndex || 0];\n            if (!sprite) {\n                continue;\n            }\n\n            const spriteScale = pixelRatio / sprite.pixelDensity;\n\n            lngLatToZoomPoint(offset, marker.position, zoom);\n\n            // Do not change the sequence of rounding, it corresponds to the rounding in Leaflet\n            offset[0] = Math.round(offset[0]);\n            offset[1] = Math.round(offset[1]);\n\n            offset[0] = Math.round(offset[0] - origin[0]) + bufferOffset[0];\n            offset[1] = Math.round(offset[1] - origin[1]) + bufferOffset[1];\n\n            offset[0] = Math.round(offset[0] * pixelRatio - sprite.size[0] * spriteScale * sprite.anchor[0]);\n            offset[1] = Math.round(offset[1] * pixelRatio - sprite.size[1] * spriteScale * sprite.anchor[1]);\n\n            if (offset[0] < 0 || offset[0] + sprite.size[0] * spriteScale > size[0] * pixelRatio ||\n                offset[1] < 0 || offset[1] + sprite.size[1] * spriteScale > size[1] * pixelRatio) {\n                continue;\n            }\n\n            // Prepare for rbush\n            data.minX = offset[0];\n            data.minY = offset[1];\n            data.maxX = offset[0] + sprite.size[0] * spriteScale;\n            data.maxY = offset[1] + sprite.size[1] * spriteScale;\n            visibleMarkers.push(data);\n\n            ctx.drawImage(\n                atlas.image,\n                sprite.position[0],\n                sprite.position[1],\n                sprite.size[0],\n                sprite.size[1],\n\n                offset[0],\n                offset[1],\n                sprite.size[0] * spriteScale,\n                sprite.size[1] * spriteScale,\n            );\n\n            if (debugDrawing) {\n                this._debugDraw(marker, offset, sprite.size);\n            }\n        }\n\n        this._hiddenFrame.tree.load(visibleMarkers);\n    }\n\n    private _debugDraw(marker: Marker, offset: Vec2, size: Vec2) {\n        const ctx = this._hiddenFrame.ctx;\n        const colors = [\n            '#000000',\n            '#ff0000',\n            '#00ff00',\n            '#0000ff',\n        ];\n        const drawingOffsets = marker.drawingOffsets;\n        if (!drawingOffsets) {\n            return;\n        }\n\n        for (let j = 0; j < drawingOffsets.length; j++) {\n            const drawingOffset = drawingOffsets[j];\n            ctx.beginPath();\n            ctx.strokeStyle = colors[j];\n            ctx.rect(\n                offset[0] - drawingOffset,\n                offset[1] - drawingOffset,\n                size[0] + drawingOffset * 2,\n                size[1] + drawingOffset * 2,\n            );\n\n            ctx.stroke();\n        }\n    }\n\n    private _createFrame(): Frame {\n        const canvas = document.createElement('canvas');\n        canvas.style.display = 'none';\n\n        // In 2gis-maps a \"position: absolute\" style affects to the canvas\n        // Remove when 2gis-maps update leaflet to 1.0.3\n        canvas.style.position = 'initial';\n\n        // We do not consider the case when 2d context is not exist\n        const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n        const tree = rbush();\n\n        this.container.appendChild(canvas);\n\n        return {\n            canvas,\n            ctx,\n            tree,\n        };\n    }\n\n    private _switchFrames() {\n        if (!this._map) {\n            return;\n        }\n\n        this._currentFrame.canvas.style.display = 'none';\n        this._hiddenFrame.canvas.style.display = 'block';\n\n        const t = this._currentFrame;\n        this._currentFrame = this._hiddenFrame;\n        this._hiddenFrame = t;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/CanvasRenderer.ts","import {\n  LngLat,\n  Vec2,\n} from './types';\n\nconst R = 6378137;\nconst MAX_LATITUDE = 85.0511287798;\n\nexport function vec2create(): Vec2 {\n    return new Float64Array(2);\n}\n\nexport function lngLatToZoomPoint(out: Vec2, lngLat: LngLat, zoom: number) {\n    latLngToMapPoint(out, lngLat);\n    mapPointToScreenPoint(out, out, zoom);\n}\n\nfunction mapPointToScreenPoint(out: Vec2, point: Vec2, zoom) {\n    const scale = 256 * Math.pow(2, zoom);\n    const k = 0.5 / (Math.PI * R);\n\n    out[0] = scale * (k * point[0] + 0.5);\n    out[1] = scale * (-k * point[1] + 0.5);\n}\n\nfunction latLngToMapPoint(out: Vec2, lngLat: LngLat) {\n    const d = Math.PI / 180;\n    const lat = Math.max(Math.min(MAX_LATITUDE, lngLat[1]), -MAX_LATITUDE);\n    const sin = Math.sin(lat * d);\n\n    out[0] = R * lngLat[0] * d;\n    out[1] = R * Math.log((1 + sin) / (1 - sin)) / 2;\n}\n\nexport const now = window.performance ? performance.now.bind(performance) : Date.now.bind(Date);\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.ts"],"sourceRoot":""}